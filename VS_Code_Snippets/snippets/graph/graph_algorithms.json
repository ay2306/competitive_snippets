{
    "Krushkal":{
        "prefix": "!!krushkal",
        "body":[
            "vector<pair<int,pair<int,int>>> edges;",
            "int krushkal(){",
            "    sort(edges.begin(),edges.end());",
            "    int ans = 0;",
            "    for(auto &i: edges){",
            "        if(findParent(i.second.first) != findParent(i.second.second)){",
            "            UNION(i.second.first,i.second.second);",
            "            ans+=i.first;",
            "        }",
            "    }",
            "    return ans;",
            "}"
        ],
        "description": "Code Snippet for Krushkal Algorithm to find Minimum Cost of Spanning Tree"
    },
    "ConvexHull":{
        "prefix":"!!convexHull",
        "body":[                       
            "struct point {",
            "    int x,y;",
            "",
            "    point(int a, int b){",
            "        x = a;",
            "        y = b;",
            "    }",
            "    ",
            "    point(){",
            "        x = 0;",
            "        y = 0;",
            "    }",
            "};",
            "",
            "point p0(INT_MAX, INT_MAX);",
            "",
            "int direction(point a, point b, point c) {",
            "int val = (b.y-a.y)*(c.x-b.x)-(b.x-a.x)*(c.y-b.y);",
            "if (val == 0)",
            "    return 0;    //colinear",
            "else if(val < 0)",
            "    return 2;    //anti-clockwise direction",
            "    return 1;    //clockwise direction",
            "}",
            "",
            "double distsq(point p0, point p1){",
            "    double val = (p0.x - p1.x)*(p0.x - p1.x) + (p0.y - p1.y)*(p0.y - p1.y);",
            "",
            "    return val;",
            "}",

            "point NextToTop(S <point> stack){",
            "    //saving the current top;",
            "    point top = stack.top();",
            "",
            "    // pop the top element and to get second to top element on top to return;",
            "    stack.pop();",
            "    point res = stack.top();",
            "    //pushing the top once again to return stack to the original state;",
            "    stack.push(top);",
            "",
            "    return res;",
            "}",
            "",
            "int comp(const void *point1, const void*point2) {",
            "    point *p1 = (point*)point1;",
            "    point *p2 = (point*)point2;",
            "    int dir = direction(p0, *p1, *p2);",
            "    if(dir == 0)",
            "        return (distsq(p0, *p2) >= distsq(p0, *p1))?-1 : 1;",
            "    return (dir==2)? -1 : 1;",
            "}",
            "",
            "V<point> ConvexHull(V<point> points, int n) {",
            "    V<point> convexHullPoints;",
            "",
            "    int minY = points[0].y, min = 0;",
            "    for(int i = 1; i<n; i++) {",
            "        int y = points[i].y;",
            "        //find bottom most or left most point",
            "        if((y < minY) || (minY == y) && points[i].x < points[min].x) {",
            "            minY = points[i].y;",
            "            min = i;",
            "        }",
            "    }",
                
            "    swap(points[0], points[min]);    //swap min point to 0th location",
            "    p0 = points[0];",
                
            "    qsort(&points[1], n-1, sizeof(point), comp);    //sort points from 1 place to end",
            "",
            "    int arrSize = 1;    //used to locate items in modified array",
            "    for(int i = 1; i<n; i++) {",
            "        //when the angle of ith and (i+1)th elements are same, remove points",
            "        while(i < n-1 && direction(p0, points[i], points[i+1]) == 0)",
            "            i++;",
            "            points[arrSize] = points[i];",
            "            arrSize++;",
            "    }",
                
            "    if(arrSize < 3)",
            "        return convexHullPoints;    //there must be at least 3 points, return empty list.",
                
            "    //create a stack and add first three points in the stack",
            "    stack<point> stk;",
            "    stk.push(points[0]); ",
            "    stk.push(points[1]); ",
            "    stk.push(points[2]);",
            "",
            "    for(int i = 3; i<arrSize; i++) {    //for remaining vertices",
            "        while(direction(NextToTop(stk), stk.top(), points[i]) != 2)",
            "            stk.pop();    //when top, second top and ith point are not making left turn, remove point",
            "            stk.push(points[i]);",
            "    }",
            "    while(!stk.empty()) {",
            "        convexHullPoints.push_back(stk.top());    //add points from stack",
            "        stk.pop();",
            "    }",
            "}"
        ],
        "description": "Code Snippet along with required functions for Convex Hull of set of points using Graham Scan Algorithm"
    }
}